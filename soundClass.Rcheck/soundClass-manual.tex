\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `soundClass'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Title]\AsIs{Automatic Sound Classification with Convolutional Neural
Networks}
\item[Version]\AsIs{0.0.0.9}
\item[Author]\AsIs{Bruno Silva [aut, cre]}
\item[Maintainer]\AsIs{Bruno Silva }\email{bmsasilva@gmail.com}\AsIs{}
\item[Description]\AsIs{Provides an all-in-one solution for automatic classification of
sound events using convolutional neural networks (CNN). By using automatic
feature selection and a user-friendly GUI for managing data and
training/deploying models, this package is intended to be used by a broad
audience as it does not require specific expertise in statistics,
programming or sound analysis.
Gibb, R., et al. (2019) <doi.org/10.1111/2041-210X.13101>
Mac Aodha, O., et al. (2018) <doi.org/10.1371/journal.pcbi.1005995>
Stowell, D., et al. (2019) <doi.org/10.1111/2041-210X.13103>
LeCun, Y., et al. (2012) <doi.org/10.1007/978-3-642-35289-8\_3>.}
\item[License]\AsIs{GPL-3}
\item[Encoding]\AsIs{UTF-8}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.1.1}
\item[Imports]\AsIs{RSQLite, seewave, DBI, dplyr, signal, tuneR, zoo, dbplyr,
magrittr, shinyFiles, shiny, utils, graphics, generics, keras,
scales, shinyjs}
\item[Depends]\AsIs{shinyBS, htmltools}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{app\_label}{Start app label recordings}{app.Rul.label}
%
\begin{Description}\relax
Starts the app to label recordings
\end{Description}
%
\begin{Usage}
\begin{verbatim}
app_label()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{app\_model}{Start app fit model}{app.Rul.model}
%
\begin{Description}\relax
Starts the app to fit  and run the model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
app_model()
\end{verbatim}
\end{Usage}
\inputencoding{utf8}
\HeaderA{auto\_id\_shiny}{Automatic classification on a set of recordings}{auto.Rul.id.Rul.shiny}
%
\begin{Description}\relax
Applies automatic classification on a set of recordings
using a fitted model
\end{Description}
%
\begin{Usage}
\begin{verbatim}
auto_id_shiny(
  model_path,
  updateProgress,
  metadata,
  file_path,
  out_file,
  out_dir,
  save_png = T,
  win_size = 50,
  plot2console = F,
  remove_noise = T,
  recursive = FALSE,
  tx = 1
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{model\_path}] An object of class 'rc', created with
the 'import\_audio' function

\item[\code{updateProgress}] Progress bar only to be used inside shiny

\item[\code{metadata}] Parameters used to create train data for fitting the model

\item[\code{file\_path}] Path to the folder containing sound recordings

\item[\code{out\_file}] Character. Name of the file to output the results.
Will be used to name the csv file and the sqlite database

\item[\code{out\_dir}] Path to the folder where the output results will be stored

\item[\code{save\_png}] Logical. Should a spectrogram of the classified recordings
with the identified event(s) and respective classification(s) be saved
as png file?

\item[\code{win\_size}] Window size to split recordings in chunks for classification.
One peak per chunk is obtained and classified

\item[\code{plot2console}] Logical. Should a spectrogram of the classified
recordings with the identified event(s) and respective classification(s)
be ploted in the console while the analysis is running?
as png file?

\item[\code{remove\_noise}] Logical. TRUE indicates that the model was fitted
with a non-relevant class which will be deleted from the final output

\item[\code{recursive}] Logical. FALSE indicates that the recordings are in
a single folder and TRUE indicates that there are recordings
inside subfolders

\item[\code{tx}] Time expanded. Only used in recorders specifically intended for
bat recordings. Can take the values "auto" or any numeric value. If the
recording is not time expanded tx must be set to 1 (the default). If it's
time expanded the numeric value correponding to the time expansion should
be indicated or "auto" should be selected. If tx = "auto" the function
assumes that sampling rates < 50kHz correponds to
tx = 10 and > 50kHz to tx = 1.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Automatic classification on a set of recordings

Runs a classification task on the recordings of a specified folder
and saves the results of the analysis
\end{Details}
%
\begin{Value}
Nothing
\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
\inputencoding{utf8}
\HeaderA{create\_db}{Create a sqlite3 database}{create.Rul.db}
%
\begin{Description}\relax
Create a sqlite3 database with a predefined table (if a
database with the specified name doesn't exist already). Two type of
databases are possible, one to store recordings annotations and another
to store the output of the classification.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
create_db(path, db_name = NA, table_name = "labels", type = "reference")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] Character. Path to the folder where the database will be created.

\item[\code{db\_name}] Character. Name of the database to be created.

\item[\code{table\_name}] Character. Name of the table to be created.
inside the database. It is mandatory to use the default table name "labels"
if the database is intended to be used in conjunction with other
functions of this package.

\item[\code{type}] Character indicating the type of database to create. Possible
options are: "reference" which creates a database to be used to store
recordings annotations for training purposes, and "id" which
creates a database to output the results of the automatic classification.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Nothing
\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
dir_path <- tempdir()
create_db(dir_path, 
db_name = "test", 
table_name = "labels",
type = "reference")
file.remove(file.path(dir_path, "test.sqlite3"))

## End(Not run)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{find\_noise}{Detect energy peaks in non-relevant recordings}{find.Rul.noise}
%
\begin{Description}\relax
Detects the temporal position of the desired number of
energy peaks in a recording of non-relevant events.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
find_noise(recording, nmax = 1, plot = F)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{recording}] Object of class "rc"

\item[\code{nmax}] Integer indicating the maximum number of peaks to detect in
the recording.

\item[\code{plot}] Logical. If TRUE a plot showing the peak(s) is returned.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Detect energy peaks in non-relevant recordings
\end{Details}
%
\begin{Value}
A vector with the temporal position of the
identified peak(s), in samples.
\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
# Create a sample wav file in a temporary directory
recording <- tuneR::noise(duration = 44100)
temp_dir <- tempdir()
rec_path <- file.path(temp_dir, "recording.wav")
tuneR::writeWave(recording, filename = rec_path)
# Import the sample wav file
new_rec <- import_audio(rec_path, butt = FALSE, tx = 1)
find_noise(new_rec, nmax = 1, plot = FALSE)
file.remove(rec_path)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{import\_audio}{Import a recording}{import.Rul.audio}
%
\begin{Description}\relax
Import a "wav" recording using \LinkA{readWave}{readWave}
and create a S3 object of class "rc". If the recording is stereo it is
\#' converted to mono by keeping the channel with overall higher amplitude
\end{Description}
%
\begin{Usage}
\begin{verbatim}
import_audio(path, butt = TRUE, low, high, tx = 1)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] Full path to the recording

\item[\code{butt}] Logical. If TRUE filters the recording with a 12th order
filter. The filter is applied twice to better cleaning of the recording

\item[\code{low}] Minimum frequency in kHz for the butterworth filter

\item[\code{high}] Maximum frequency in kHz for the butterworth filter

\item[\code{tx}] Time expanded. Only used in recorders specifically intended for
bat recordings. Can take the values "auto" or any numeric value. If the
recording is not time expanded tx must be set to 1 (the default). If it's
time expanded the numeric value correponding to the time expansion should
be indicated or "auto" should be selected. If tx = "auto" the function
assumes that sampling rates < 50kHz correponds to
tx = 10 and > 50kHz to tx = 1.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Import a recording
\end{Details}
%
\begin{Value}
an object of class "rc". This object is a list
with the following components:
\begin{itemize}

\item{} sound\_samples -- sound samples of the recording
\item{} file\_name -- name of the recording
\item{} file\_time -- time of modification of the file (indicated for
Pettersson Elektronic detectors, for other manufactures creation time should
be preferable but it's not implemented yet)
\item{} fs -- sample frequency
\item{} tx -- expanded time factor

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
# Create a sample wav file in a temporary directory
recording <- tuneR::sine(440)
temp_dir <- tempdir()
rec_path <- file.path(temp_dir, "recording.wav")
tuneR::writeWave(recording, filename = rec_path)
# Import the sample wav file
new_rec <- import_audio(rec_path, low = 1, high = 20, tx = 1)
new_rec
file.remove(rec_path)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{ms2samples}{Convert between time and number of samples in sound files}{ms2samples}
%
\begin{Description}\relax
Convert time to number of samples or vice-versa
in sound files.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ms2samples(value, fs = 300000, tx = 1, inv = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{value}] Numeric representing time in ms or number of samples.

\item[\code{fs}] Integer. The sampling frequency in samples per second.

\item[\code{tx}] Integer. Time expansion factor.

\item[\code{inv}] Logical. If TRUE converts time to number of samples, if FALSE
number of samples to time.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Convert between time and number of samples in sound files
\end{Details}
%
\begin{Value}
if inv = TRUE returns number of samples, if unv = FALSE
returns time in ms
\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
%
\begin{Examples}
\begin{ExampleCode}
ms2samples(150000, fs = 300000, tx = 1, inv = FALSE)
ms2samples(100, fs = 300000, tx = 1, inv = TRUE)
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{spectro\_calls}{Generate spectrograms from recording labels.}{spectro.Rul.calls}
%
\begin{Description}\relax
Generates spectrograms from recording's labels for
classification purposes. The spectrogram parameters are user defined
and should be selected depending on the type of sound event to classify.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
spectro_calls(files_path, updateProgress,
db_path, spec_size = NA, window_length = NA,
frequency_resolution = NA, time_step_size = NA, 
dynamic_range = NA, freq_range = NA, tx = 1, seed = 1002)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{files\_path}] Path for the folder containing sound recordings

\item[\code{updateProgress}] Progress bar only to be used inside shiny

\item[\code{db\_path}] Path for the database of recording labels created with the
shinny app provided in the package

\item[\code{spec\_size}] Spectrogram size in ms

\item[\code{window\_length}] Moving window length to create the spectrogram in ms

\item[\code{frequency\_resolution}] Spectrogram frequency resolution with higher
numbers meaning better resolution. Specifically, for any integer X provided,
1/X the analysis bandwidth (as determined by the number of samples
in the analysis window) will be used. Note that this greatly impacts
processing time, so adjust with care!

\item[\code{time\_step\_size}] Moving window step in ms

\item[\code{dynamic\_range}] Threshold of minimum intensity values to show
in the spectrogram

\item[\code{freq\_range}] Frequency range of the spectrogram. Vector with two values,
refering to the minimum and maximum frequency to show in the spectrogram

\item[\code{tx}] Time expanded. Only used in recorders specifically intended for
bat recordings. Can take the values "auto" or any numeric value. If the
recording is not time expanded tx must be set to 1 (the default). If it's
time expanded the numeric value correponding to the time expansion should
be indicated or "auto" should be selected. If tx = "auto" the function
assumes that sampling rates < 50kHz correponds to
tx = 10 and > 50kHz to tx = 1.

\item[\code{seed}] Integer. Define a custom seed for randomizing data
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Generate spectrograms from labels
\end{Details}
%
\begin{Value}
A list with the following components:
\begin{itemize}

\item{} data\_x -- an array with the spectrogram matrices
\item{} data\_y -- the labels for each matrix in one-hot-encoded format
\item{} parameters -- the parameters used to create the matrices
\item{} labels\_df -- the labels with their respective numeric index

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Bruno Silva
\end{Author}
\inputencoding{utf8}
\HeaderA{\Rpercent{}>\Rpercent{}}{Pipe operator}{.Rpcent.>.Rpcent.}
%
\begin{Description}\relax
See documentation of package magrittr for details.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
lhs %>% rhs
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lhs}] A value or the magrittr placeholder.

\item[\code{rhs}] A function call using the magrittr semantics
\end{ldescription}
\end{Arguments}
\printindex{}
\end{document}
